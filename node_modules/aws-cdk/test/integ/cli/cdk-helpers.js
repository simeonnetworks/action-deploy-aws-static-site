"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rememberToDeleteBucket = exports.shell = exports.cleanup = exports.deleteableStacks = exports.prepareAppFixture = exports.cloneDirectory = exports.fullStackName = exports.cdk = exports.cdkDestroy = exports.cdkDeploy = exports.log = exports.STACK_NAME_PREFIX = exports.INTEG_TEST_DIR = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const aws_helpers_1 = require("./aws-helpers");
exports.INTEG_TEST_DIR = path.join(os.tmpdir(), 'cdk-integ-test2');
// create a unique stack name prefix for this test test run. this is passed
// through an environment variable to app.js so that all stacks use this prefix.
const timestamp = new Date().toISOString().replace(/[^0-9]/g, '');
exports.STACK_NAME_PREFIX = `cdktest-${timestamp}`;
process.stdout.write('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
process.stdout.write(` All stacks created by this test run will have the prefix: ${exports.STACK_NAME_PREFIX}\n`);
process.stdout.write('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
function log(x) {
    process.stderr.write(x + '\n');
}
exports.log = log;
async function cdkDeploy(stackNames, options = {}) {
    var _a, _b;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    const neverRequireApproval = (_a = options.neverRequireApproval) !== null && _a !== void 0 ? _a : true;
    return await cdk(['deploy',
        ...(neverRequireApproval ? ['--require-approval=never'] : []), // Default to no approval in an unattended test
        ...((_b = options.options) !== null && _b !== void 0 ? _b : []), ...fullStackName(stackNames)], options);
}
exports.cdkDeploy = cdkDeploy;
async function cdkDestroy(stackNames, options = {}) {
    var _a;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    return await cdk(['destroy',
        '-f', // We never want a prompt in an unattended test
        ...((_a = options.options) !== null && _a !== void 0 ? _a : []), ...fullStackName(stackNames)], options);
}
exports.cdkDestroy = cdkDestroy;
async function cdk(args, options = {}) {
    return await shell(['cdk', ...args], {
        cwd: exports.INTEG_TEST_DIR,
        ...options,
        modEnv: {
            AWS_REGION: (await aws_helpers_1.testEnv()).region,
            AWS_DEFAULT_REGION: (await aws_helpers_1.testEnv()).region,
            STACK_NAME_PREFIX: exports.STACK_NAME_PREFIX,
            ...options.modEnv,
        },
    });
}
exports.cdk = cdk;
function fullStackName(stackNames) {
    if (typeof stackNames === 'string') {
        return `${exports.STACK_NAME_PREFIX}-${stackNames}`;
    }
    else {
        return stackNames.map(s => `${exports.STACK_NAME_PREFIX}-${s}`);
    }
}
exports.fullStackName = fullStackName;
/**
 * Prepare a target dir byreplicating a source directory
 */
async function cloneDirectory(source, target) {
    await shell(['rm', '-rf', target]);
    await shell(['mkdir', '-p', target]);
    await shell(['cp', '-R', source + '/*', target]);
}
exports.cloneDirectory = cloneDirectory;
/**
 * Prepare the app fixture
 *
 * If this is done in the main test script, it will be skipped
 * in the subprocess scripts since the app fixture can just be reused.
 */
async function prepareAppFixture() {
    await cloneDirectory(path.join(__dirname, 'app'), exports.INTEG_TEST_DIR);
    await shell(['npm', 'install',
        '@aws-cdk/core',
        '@aws-cdk/aws-sns',
        '@aws-cdk/aws-iam',
        '@aws-cdk/aws-lambda',
        '@aws-cdk/aws-ssm',
        '@aws-cdk/aws-ecr-assets',
        '@aws-cdk/aws-cloudformation',
        '@aws-cdk/aws-ec2'], {
        cwd: exports.INTEG_TEST_DIR,
    });
}
exports.prepareAppFixture = prepareAppFixture;
/**
 * Return the stacks starting with our testing prefix that should be deleted
 */
async function deleteableStacks(prefix) {
    var _a;
    const statusFilter = [
        'CREATE_IN_PROGRESS', 'CREATE_FAILED', 'CREATE_COMPLETE',
        'ROLLBACK_IN_PROGRESS', 'ROLLBACK_FAILED', 'ROLLBACK_COMPLETE',
        'DELETE_FAILED',
        'UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_COMPLETE', 'UPDATE_ROLLBACK_IN_PROGRESS',
        'UPDATE_ROLLBACK_FAILED',
        'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_ROLLBACK_COMPLETE', 'REVIEW_IN_PROGRESS',
        'IMPORT_IN_PROGRESS', 'IMPORT_COMPLETE',
        'IMPORT_ROLLBACK_IN_PROGRESS', 'IMPORT_ROLLBACK_FAILED',
        'IMPORT_ROLLBACK_COMPLETE',
    ];
    const response = await aws_helpers_1.cloudFormation('describeStacks', {});
    return ((_a = response.Stacks) !== null && _a !== void 0 ? _a : [])
        .filter(s => s.StackName.startsWith(prefix))
        .filter(s => statusFilter.includes(s.StackStatus))
        .filter(s => s.RootId === undefined); // Only delete parent stacks. Nested stacks are deleted in the process
}
exports.deleteableStacks = deleteableStacks;
/**
 * Cleanup leftover stacks and buckets
 */
async function cleanup() {
    const stacksToDelete = await deleteableStacks(exports.STACK_NAME_PREFIX);
    // Bootstrap stacks have buckets that need to be cleaned
    const bucketNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('BucketName', stack)).filter(defined);
    await Promise.all(bucketNames.map(aws_helpers_1.emptyBucket));
    // Bootstrap stacks have ECR repositories with images which should be deleted
    const imageRepositoryNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('ImageRepositoryName', stack)).filter(defined);
    await Promise.all(imageRepositoryNames.map(aws_helpers_1.deleteImageRepository));
    await aws_helpers_1.deleteStacks(...stacksToDelete.map(s => s.StackName));
    // We might have leaked some buckets by upgrading the bootstrap stack. Be
    // sure to clean everything.
    for (const bucket of bucketsToDelete) {
        await aws_helpers_1.deleteBucket(bucket);
    }
    bucketsToDelete = [];
}
exports.cleanup = cleanup;
/**
 * A shell command that does what you want
 *
 * Is platform-aware, handles errors nicely.
 */
async function shell(command, options = {}) {
    var _a;
    if (options.modEnv && options.env) {
        throw new Error('Use either env or modEnv but not both');
    }
    log(`ðŸ’» ${command.join(' ')}`);
    const env = (_a = options.env) !== null && _a !== void 0 ? _a : (options.modEnv ? { ...process.env, ...options.modEnv } : undefined);
    const child = child_process.spawn(command[0], command.slice(1), {
        ...options,
        env,
        // Need this for Windows where we want .cmd and .bat to be found as well.
        shell: true,
        stdio: ['ignore', 'pipe', 'pipe'],
    });
    return new Promise((resolve, reject) => {
        const stdout = new Array();
        const stderr = new Array();
        child.stdout.on('data', chunk => {
            process.stdout.write(chunk);
            stdout.push(chunk);
        });
        child.stderr.on('data', chunk => {
            var _a;
            process.stderr.write(chunk);
            if ((_a = options.captureStderr) !== null && _a !== void 0 ? _a : true) {
                stderr.push(chunk);
            }
        });
        child.once('error', reject);
        child.once('close', code => {
            if (code === 0 || options.allowErrExit) {
                resolve((Buffer.concat(stdout).toString('utf-8') + Buffer.concat(stderr).toString('utf-8')).trim());
            }
            else {
                reject(new Error(`'${command.join(' ')}' exited with error code ${code}: ${Buffer.concat(stderr).toString('utf-8').trim()}`));
            }
        });
    });
}
exports.shell = shell;
let bucketsToDelete = new Array();
/**
 * Append this to the list of buckets to potentially delete
 *
 * At the end of a test, we clean up buckets that may not have gotten destroyed
 * (for whatever reason).
 */
function rememberToDeleteBucket(bucketName) {
    bucketsToDelete.push(bucketName);
}
exports.rememberToDeleteBucket = rememberToDeleteBucket;
function defined(x) {
    return x !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrQ0FBeUk7QUFFNUgsUUFBQSxjQUFjLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztBQUV4RSwyRUFBMkU7QUFDM0UsZ0ZBQWdGO0FBQ2hGLE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyRCxRQUFBLGlCQUFpQixHQUFHLFdBQVcsU0FBUyxFQUFFLENBQUM7QUFFeEQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMseUdBQXlHLENBQUMsQ0FBQztBQUNoSSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw4REFBOEQseUJBQWlCLElBQUksQ0FBQyxDQUFDO0FBQzFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHlHQUF5RyxDQUFDLENBQUM7QUE0QmhJLFNBQWdCLEdBQUcsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRkQsa0JBRUM7QUFFTSxLQUFLLFVBQVUsU0FBUyxDQUFDLFVBQTZCLEVBQUUsVUFBeUIsRUFBRTs7SUFDeEYsVUFBVSxHQUFHLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBRXhFLE1BQU0sb0JBQW9CLFNBQUcsT0FBTyxDQUFDLG9CQUFvQixtQ0FBSSxJQUFJLENBQUM7SUFFbEUsT0FBTyxNQUFNLEdBQUcs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QUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3RDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUNyRztpQkFBTTtnQkFDTCxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsSUFBSSxLQUFLLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQy9IO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUEzQ0Qsc0JBMkNDO0FBRUQsSUFBSSxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztBQUUxQzs7Ozs7R0FLRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLFVBQWtCO0lBQ3ZELGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUZELHdEQUVDO0FBRUQsU0FBUyxPQUFPLENBQUksQ0FBSTtJQUN0QixPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY2xvdWRGb3JtYXRpb24sIGRlbGV0ZUJ1Y2tldCwgZGVsZXRlSW1hZ2VSZXBvc2l0b3J5LCBkZWxldGVTdGFja3MsIGVtcHR5QnVja2V0LCBvdXRwdXRGcm9tU3RhY2ssIHRlc3RFbnYgfSBmcm9tICcuL2F3cy1oZWxwZXJzJztcblxuZXhwb3J0IGNvbnN0IElOVEVHX1RFU1RfRElSID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWludGVnLXRlc3QyJyk7XG5cbi8vIGNyZWF0ZSBhIHVuaXF1ZSBzdGFjayBuYW1lIHByZWZpeCBmb3IgdGhpcyB0ZXN0IHRlc3QgcnVuLiB0aGlzIGlzIHBhc3NlZFxuLy8gdGhyb3VnaCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBhcHAuanMgc28gdGhhdCBhbGwgc3RhY2tzIHVzZSB0aGlzIHByZWZpeC5cbmNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bXjAtOV0vZywgJycpO1xuZXhwb3J0IGNvbnN0IFNUQUNLX05BTUVfUFJFRklYID0gYGNka3Rlc3QtJHt0aW1lc3RhbXB9YDtcblxucHJvY2Vzcy5zdGRvdXQud3JpdGUoJ35+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XFxuJyk7XG5wcm9jZXNzLnN0ZG91dC53cml0ZShgIEFsbCBzdGFja3MgY3JlYXRlZCBieSB0aGlzIHRlc3QgcnVuIHdpbGwgaGF2ZSB0aGUgcHJlZml4OiAke1NUQUNLX05BTUVfUFJFRklYfVxcbmApO1xucHJvY2Vzcy5zdGRvdXQud3JpdGUoJ35+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XFxuJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hlbGxPcHRpb25zIGV4dGVuZHMgY2hpbGRfcHJvY2Vzcy5TcGF3bk9wdGlvbnMge1xuICAvKipcbiAgICogUHJvcGVydGllcyB0byBhZGQgdG8gJ2VudidcbiAgICovXG4gIG1vZEVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgLyoqXG4gICAqIERvbid0IGZhaWwgd2hlbiBleGl0aW5nIHdpdGggYW4gZXJyb3JcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFsbG93RXJyRXhpdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY2FwdHVyZSBzdGRlcnJcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2FwdHVyZVN0ZGVycj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2RrQ2xpT3B0aW9ucyBleHRlbmRzIFNoZWxsT3B0aW9ucyB7XG4gIG9wdGlvbnM/OiBzdHJpbmdbXTtcbiAgbmV2ZXJSZXF1aXJlQXBwcm92YWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKHg6IHN0cmluZykge1xuICBwcm9jZXNzLnN0ZGVyci53cml0ZSh4ICsgJ1xcbicpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2RrRGVwbG95KHN0YWNrTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdLCBvcHRpb25zOiBDZGtDbGlPcHRpb25zID0ge30pIHtcbiAgc3RhY2tOYW1lcyA9IHR5cGVvZiBzdGFja05hbWVzID09PSAnc3RyaW5nJyA/IFtzdGFja05hbWVzXSA6IHN0YWNrTmFtZXM7XG5cbiAgY29uc3QgbmV2ZXJSZXF1aXJlQXBwcm92YWwgPSBvcHRpb25zLm5ldmVyUmVxdWlyZUFwcHJvdmFsID8/IHRydWU7XG5cbiAgcmV0dXJuIGF3YWl0IGNkayhbJ2RlcGxveScsXG4gICAgLi4uKG5ldmVyUmVxdWlyZUFwcHJvdmFsID8gWyctLXJlcXVpcmUtYXBwcm92YWw9bmV2ZXInXSA6IFtdKSwgLy8gRGVmYXVsdCB0byBubyBhcHByb3ZhbCBpbiBhbiB1bmF0dGVuZGVkIHRlc3RcbiAgICAuLi4ob3B0aW9ucy5vcHRpb25zID8/IFtdKSxcbiAgICAuLi5mdWxsU3RhY2tOYW1lKHN0YWNrTmFtZXMpXSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjZGtEZXN0cm95KHN0YWNrTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdLCBvcHRpb25zOiBDZGtDbGlPcHRpb25zID0ge30pIHtcbiAgc3RhY2tOYW1lcyA9IHR5cGVvZiBzdGFja05hbWVzID09PSAnc3RyaW5nJyA/IFtzdGFja05hbWVzXSA6IHN0YWNrTmFtZXM7XG5cbiAgcmV0dXJuIGF3YWl0IGNkayhbJ2Rlc3Ryb3knLFxuICAgICctZicsIC8vIFdlIG5ldmVyIHdhbnQgYSBwcm9tcHQgaW4gYW4gdW5hdHRlbmRlZCB0ZXN0XG4gICAgLi4uKG9wdGlvbnMub3B0aW9ucyA/PyBbXSksXG4gICAgLi4uZnVsbFN0YWNrTmFtZShzdGFja05hbWVzKV0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2RrKGFyZ3M6IHN0cmluZ1tdLCBvcHRpb25zOiBDZGtDbGlPcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IHNoZWxsKFsnY2RrJywgLi4uYXJnc10sIHtcbiAgICBjd2Q6IElOVEVHX1RFU1RfRElSLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgbW9kRW52OiB7XG4gICAgICBBV1NfUkVHSU9OOiAoYXdhaXQgdGVzdEVudigpKS5yZWdpb24sXG4gICAgICBBV1NfREVGQVVMVF9SRUdJT046IChhd2FpdCB0ZXN0RW52KCkpLnJlZ2lvbixcbiAgICAgIFNUQUNLX05BTUVfUFJFRklYLFxuICAgICAgLi4ub3B0aW9ucy5tb2RFbnYsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdWxsU3RhY2tOYW1lKHN0YWNrTmFtZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bGxTdGFja05hbWUoc3RhY2tOYW1lczogc3RyaW5nW10pOiBzdHJpbmdbXTtcbmV4cG9ydCBmdW5jdGlvbiBmdWxsU3RhY2tOYW1lKHN0YWNrTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdKTogc3RyaW5nIHwgc3RyaW5nW10ge1xuICBpZiAodHlwZW9mIHN0YWNrTmFtZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGAke1NUQUNLX05BTUVfUFJFRklYfS0ke3N0YWNrTmFtZXN9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhY2tOYW1lcy5tYXAocyA9PiBgJHtTVEFDS19OQU1FX1BSRUZJWH0tJHtzfWApO1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZSBhIHRhcmdldCBkaXIgYnlyZXBsaWNhdGluZyBhIHNvdXJjZSBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb25lRGlyZWN0b3J5KHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZykge1xuICBhd2FpdCBzaGVsbChbJ3JtJywgJy1yZicsIHRhcmdldF0pO1xuICBhd2FpdCBzaGVsbChbJ21rZGlyJywgJy1wJywgdGFyZ2V0XSk7XG4gIGF3YWl0IHNoZWxsKFsnY3AnLCAnLVInLCBzb3VyY2UgKyAnLyonLCB0YXJnZXRdKTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBhcHAgZml4dHVyZVxuICpcbiAqIElmIHRoaXMgaXMgZG9uZSBpbiB0aGUgbWFpbiB0ZXN0IHNjcmlwdCwgaXQgd2lsbCBiZSBza2lwcGVkXG4gKiBpbiB0aGUgc3VicHJvY2VzcyBzY3JpcHRzIHNpbmNlIHRoZSBhcHAgZml4dHVyZSBjYW4ganVzdCBiZSByZXVzZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQXBwRml4dHVyZSgpIHtcbiAgYXdhaXQgY2xvbmVEaXJlY3RvcnkocGF0aC5qb2luKF9fZGlybmFtZSwgJ2FwcCcpLCBJTlRFR19URVNUX0RJUik7XG5cbiAgYXdhaXQgc2hlbGwoWyducG0nLCAnaW5zdGFsbCcsXG4gICAgJ0Bhd3MtY2RrL2NvcmUnLFxuICAgICdAYXdzLWNkay9hd3Mtc25zJyxcbiAgICAnQGF3cy1jZGsvYXdzLWlhbScsXG4gICAgJ0Bhd3MtY2RrL2F3cy1sYW1iZGEnLFxuICAgICdAYXdzLWNkay9hd3Mtc3NtJyxcbiAgICAnQGF3cy1jZGsvYXdzLWVjci1hc3NldHMnLFxuICAgICdAYXdzLWNkay9hd3MtY2xvdWRmb3JtYXRpb24nLFxuICAgICdAYXdzLWNkay9hd3MtZWMyJ10sIHtcbiAgICBjd2Q6IElOVEVHX1RFU1RfRElSLFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YWNrcyBzdGFydGluZyB3aXRoIG91ciB0ZXN0aW5nIHByZWZpeCB0aGF0IHNob3VsZCBiZSBkZWxldGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVhYmxlU3RhY2tzKHByZWZpeDogc3RyaW5nKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tbXT4ge1xuICBjb25zdCBzdGF0dXNGaWx0ZXIgPSBbXG4gICAgJ0NSRUFURV9JTl9QUk9HUkVTUycsICdDUkVBVEVfRkFJTEVEJywgJ0NSRUFURV9DT01QTEVURScsXG4gICAgJ1JPTExCQUNLX0lOX1BST0dSRVNTJywgJ1JPTExCQUNLX0ZBSUxFRCcsICdST0xMQkFDS19DT01QTEVURScsXG4gICAgJ0RFTEVURV9GQUlMRUQnLFxuICAgICdVUERBVEVfSU5fUFJPR1JFU1MnLCAnVVBEQVRFX0NPTVBMRVRFX0NMRUFOVVBfSU5fUFJPR1JFU1MnLFxuICAgICdVUERBVEVfQ09NUExFVEUnLCAnVVBEQVRFX1JPTExCQUNLX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX1JPTExCQUNLX0ZBSUxFRCcsXG4gICAgJ1VQREFURV9ST0xMQkFDS19DT01QTEVURV9DTEVBTlVQX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX1JPTExCQUNLX0NPTVBMRVRFJywgJ1JFVklFV19JTl9QUk9HUkVTUycsXG4gICAgJ0lNUE9SVF9JTl9QUk9HUkVTUycsICdJTVBPUlRfQ09NUExFVEUnLFxuICAgICdJTVBPUlRfUk9MTEJBQ0tfSU5fUFJPR1JFU1MnLCAnSU1QT1JUX1JPTExCQUNLX0ZBSUxFRCcsXG4gICAgJ0lNUE9SVF9ST0xMQkFDS19DT01QTEVURScsXG4gIF07XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbG91ZEZvcm1hdGlvbignZGVzY3JpYmVTdGFja3MnLCB7fSk7XG5cbiAgcmV0dXJuIChyZXNwb25zZS5TdGFja3MgPz8gW10pXG4gICAgLmZpbHRlcihzID0+IHMuU3RhY2tOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAuZmlsdGVyKHMgPT4gc3RhdHVzRmlsdGVyLmluY2x1ZGVzKHMuU3RhY2tTdGF0dXMpKVxuICAgIC5maWx0ZXIocyA9PiBzLlJvb3RJZCA9PT0gdW5kZWZpbmVkKTsgLy8gT25seSBkZWxldGUgcGFyZW50IHN0YWNrcy4gTmVzdGVkIHN0YWNrcyBhcmUgZGVsZXRlZCBpbiB0aGUgcHJvY2Vzc1xufVxuXG4vKipcbiAqIENsZWFudXAgbGVmdG92ZXIgc3RhY2tzIGFuZCBidWNrZXRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBzdGFja3NUb0RlbGV0ZSA9IGF3YWl0IGRlbGV0ZWFibGVTdGFja3MoU1RBQ0tfTkFNRV9QUkVGSVgpO1xuXG4gIC8vIEJvb3RzdHJhcCBzdGFja3MgaGF2ZSBidWNrZXRzIHRoYXQgbmVlZCB0byBiZSBjbGVhbmVkXG4gIGNvbnN0IGJ1Y2tldE5hbWVzID0gc3RhY2tzVG9EZWxldGUubWFwKHN0YWNrID0+IG91dHB1dEZyb21TdGFjaygnQnVja2V0TmFtZScsIHN0YWNrKSkuZmlsdGVyKGRlZmluZWQpO1xuICBhd2FpdCBQcm9taXNlLmFsbChidWNrZXROYW1lcy5tYXAoZW1wdHlCdWNrZXQpKTtcblxuICAvLyBCb290c3RyYXAgc3RhY2tzIGhhdmUgRUNSIHJlcG9zaXRvcmllcyB3aXRoIGltYWdlcyB3aGljaCBzaG91bGQgYmUgZGVsZXRlZFxuICBjb25zdCBpbWFnZVJlcG9zaXRvcnlOYW1lcyA9IHN0YWNrc1RvRGVsZXRlLm1hcChzdGFjayA9PiBvdXRwdXRGcm9tU3RhY2soJ0ltYWdlUmVwb3NpdG9yeU5hbWUnLCBzdGFjaykpLmZpbHRlcihkZWZpbmVkKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoaW1hZ2VSZXBvc2l0b3J5TmFtZXMubWFwKGRlbGV0ZUltYWdlUmVwb3NpdG9yeSkpO1xuXG4gIGF3YWl0IGRlbGV0ZVN0YWNrcyguLi5zdGFja3NUb0RlbGV0ZS5tYXAocyA9PiBzLlN0YWNrTmFtZSkpO1xuXG4gIC8vIFdlIG1pZ2h0IGhhdmUgbGVha2VkIHNvbWUgYnVja2V0cyBieSB1cGdyYWRpbmcgdGhlIGJvb3RzdHJhcCBzdGFjay4gQmVcbiAgLy8gc3VyZSB0byBjbGVhbiBldmVyeXRoaW5nLlxuICBmb3IgKGNvbnN0IGJ1Y2tldCBvZiBidWNrZXRzVG9EZWxldGUpIHtcbiAgICBhd2FpdCBkZWxldGVCdWNrZXQoYnVja2V0KTtcbiAgfVxuICBidWNrZXRzVG9EZWxldGUgPSBbXTtcbn1cblxuLyoqXG4gKiBBIHNoZWxsIGNvbW1hbmQgdGhhdCBkb2VzIHdoYXQgeW91IHdhbnRcbiAqXG4gKiBJcyBwbGF0Zm9ybS1hd2FyZSwgaGFuZGxlcyBlcnJvcnMgbmljZWx5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hlbGwoY29tbWFuZDogc3RyaW5nW10sIG9wdGlvbnM6IFNoZWxsT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKG9wdGlvbnMubW9kRW52ICYmIG9wdGlvbnMuZW52KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgZWl0aGVyIGVudiBvciBtb2RFbnYgYnV0IG5vdCBib3RoJyk7XG4gIH1cblxuICBsb2coYPCfkrsgJHtjb21tYW5kLmpvaW4oJyAnKX1gKTtcblxuICBjb25zdCBlbnYgPSBvcHRpb25zLmVudiA/PyAob3B0aW9ucy5tb2RFbnYgPyB7Li4ucHJvY2Vzcy5lbnYsIC4uLm9wdGlvbnMubW9kRW52fSA6IHVuZGVmaW5lZCk7XG5cbiAgY29uc3QgY2hpbGQgPSBjaGlsZF9wcm9jZXNzLnNwYXduKGNvbW1hbmRbMF0sIGNvbW1hbmQuc2xpY2UoMSksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVudixcbiAgICAvLyBOZWVkIHRoaXMgZm9yIFdpbmRvd3Mgd2hlcmUgd2Ugd2FudCAuY21kIGFuZCAuYmF0IHRvIGJlIGZvdW5kIGFzIHdlbGwuXG4gICAgc2hlbGw6IHRydWUsXG4gICAgc3RkaW86IFsgJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnIF0sXG4gIH0pO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzdGRvdXQgPSBuZXcgQXJyYXk8QnVmZmVyPigpO1xuICAgIGNvbnN0IHN0ZGVyciA9IG5ldyBBcnJheTxCdWZmZXI+KCk7XG5cbiAgICBjaGlsZC5zdGRvdXQhLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY2h1bmspO1xuICAgICAgc3Rkb3V0LnB1c2goY2h1bmspO1xuICAgIH0pO1xuXG4gICAgY2hpbGQuc3RkZXJyIS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGNodW5rKTtcbiAgICAgIGlmIChvcHRpb25zLmNhcHR1cmVTdGRlcnIgPz8gdHJ1ZSkge1xuICAgICAgICBzdGRlcnIucHVzaChjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjaGlsZC5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICBjaGlsZC5vbmNlKCdjbG9zZScsIGNvZGUgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IDAgfHwgb3B0aW9ucy5hbGxvd0VyckV4aXQpIHtcbiAgICAgICAgcmVzb2x2ZSgoQnVmZmVyLmNvbmNhdChzdGRvdXQpLnRvU3RyaW5nKCd1dGYtOCcpICsgQnVmZmVyLmNvbmNhdChzdGRlcnIpLnRvU3RyaW5nKCd1dGYtOCcpKS50cmltKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgJyR7Y29tbWFuZC5qb2luKCcgJyl9JyBleGl0ZWQgd2l0aCBlcnJvciBjb2RlICR7Y29kZX06ICR7QnVmZmVyLmNvbmNhdChzdGRlcnIpLnRvU3RyaW5nKCd1dGYtOCcpLnRyaW0oKX1gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5sZXQgYnVja2V0c1RvRGVsZXRlID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuLyoqXG4gKiBBcHBlbmQgdGhpcyB0byB0aGUgbGlzdCBvZiBidWNrZXRzIHRvIHBvdGVudGlhbGx5IGRlbGV0ZVxuICpcbiAqIEF0IHRoZSBlbmQgb2YgYSB0ZXN0LCB3ZSBjbGVhbiB1cCBidWNrZXRzIHRoYXQgbWF5IG5vdCBoYXZlIGdvdHRlbiBkZXN0cm95ZWRcbiAqIChmb3Igd2hhdGV2ZXIgcmVhc29uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbWVtYmVyVG9EZWxldGVCdWNrZXQoYnVja2V0TmFtZTogc3RyaW5nKSB7XG4gIGJ1Y2tldHNUb0RlbGV0ZS5wdXNoKGJ1Y2tldE5hbWUpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVkPEE+KHg6IEEpOiB4IGlzIE5vbk51bGxhYmxlPEE+IHtcbiAgcmV0dXJuIHggIT09IHVuZGVmaW5lZDtcbn0iXX0=