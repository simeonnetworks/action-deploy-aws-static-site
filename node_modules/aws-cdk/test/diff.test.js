"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const string_decoder_1 = require("string_decoder");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cloudformation_deployments_1 = require("../lib/api/cloudformation-deployments");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
const util_1 = require("./util");
let cloudExecutable;
let cloudFormation;
let toolkit;
beforeEach(() => {
    cloudExecutable = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'A',
                template: { resource: 'A' },
            },
            {
                stackName: 'B',
                depends: ['A'],
                template: { resource: 'B' },
            },
            {
                stackName: 'C',
                depends: ['A'],
                template: { resource: 'C' },
                metadata: {
                    '/resource': [
                        {
                            type: cxschema.ArtifactMetadataEntryType.ERROR,
                            data: 'this is an error',
                        },
                    ],
                },
            },
            {
                stackName: 'D',
                template: { resource: 'D' },
            }],
    });
    cloudFormation = util_1.classMockOf(cloudformation_deployments_1.CloudFormationDeployments);
    toolkit = new cdk_toolkit_1.CdkToolkit({
        cloudExecutable,
        cloudFormation,
        configuration: cloudExecutable.configuration,
        sdkProvider: cloudExecutable.sdkProvider,
    });
    // Default implementations
    cloudFormation.readCurrentTemplate.mockImplementation((stackArtifact) => {
        if (stackArtifact.stackName === 'D') {
            return Promise.resolve({ resource: 'D' });
        }
        return Promise.resolve({});
    });
    cloudFormation.deployStack.mockImplementation((options) => Promise.resolve({
        noOp: true,
        outputs: {},
        stackArn: '',
        stackArtifact: options.stack,
    }));
});
test('diff can diff multiple stacks', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['B'],
        stream: buffer,
    });
    // THEN
    const plainTextOutput = buffer.data.replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
    expect(plainTextOutput).toContain('Stack A');
    expect(plainTextOutput).toContain('Stack B');
    expect(exitCode).toBe(0);
});
test('exits with 1 with diffs and fail set to true', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['A'],
        stream: buffer,
        fail: true,
    });
    // THEN
    expect(exitCode).toBe(1);
});
test('exits with 1 with diff in first stack, but not in second stack and fail set to true', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['A', 'D'],
        stream: buffer,
        fail: true,
    });
    // THEN
    expect(exitCode).toBe(1);
});
test('throws an error during diffs on stack with error metadata', async () => {
    const buffer = new StringWritable();
    // WHEN
    try {
        const exitCode = await toolkit.diff({
            stackNames: ['C'],
            stream: buffer,
        });
        // THEN
        expect(exitCode).toBe(1);
    }
    catch (e) {
        expect(e.toString()).toContain('Found errors');
    }
});
class StringWritable extends stream_1.Writable {
    constructor(options = {}) {
        super(options);
        this._decoder = new string_decoder_1.StringDecoder(options && options.defaultEncoding);
        this.data = '';
    }
    _write(chunk, encoding, callback) {
        if (encoding === 'buffer') {
            chunk = this._decoder.write(chunk);
        }
        this.data += chunk;
        callback();
    }
    _final(callback) {
        this.data += this._decoder.end();
        callback();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlmZi50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGlmZi50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQWtDO0FBQ2xDLG1EQUFtRTtBQUNuRSwyREFBMkQ7QUFFM0Qsc0ZBQWtGO0FBQ2xGLG9EQUFnRDtBQUNoRCxpQ0FBMEQ7QUFFMUQsSUFBSSxlQUFvQyxDQUFDO0FBQ3pDLElBQUksY0FBc0QsQ0FBQztBQUMzRCxJQUFJLE9BQW1CLENBQUM7QUFDeEIsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUNkLGVBQWUsR0FBRyxJQUFJLDBCQUFtQixDQUFDO1FBQ3hDLE1BQU0sRUFBRSxDQUFDO2dCQUNQLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7YUFDNUI7WUFDRDtnQkFDRSxTQUFTLEVBQUUsR0FBRztnQkFDZCxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRTthQUM1QjtZQUNEO2dCQUNFLFNBQVMsRUFBRSxHQUFHO2dCQUNkLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFDO2dCQUMxQixRQUFRLEVBQUU7b0JBQ1IsV0FBVyxFQUFFO3dCQUNYOzRCQUNFLElBQUksRUFBRSxRQUFRLENBQUMseUJBQXlCLENBQUMsS0FBSzs0QkFDOUMsSUFBSSxFQUFFLGtCQUFrQjt5QkFDekI7cUJBQ0Y7aUJBQ0Y7YUFDRjtZQUNEO2dCQUNFLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7YUFDNUIsQ0FBQztLQUNILENBQUMsQ0FBQztJQUVILGNBQWMsR0FBRyxrQkFBVyxDQUFDLHNEQUF5QixDQUFDLENBQUM7SUFFeEQsT0FBTyxHQUFHLElBQUksd0JBQVUsQ0FBQztRQUN2Qixl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U3RyaW5nRGVjb2RlciwgU3RyaW5nRGVjb2RlciAgfSBmcm9tICdzdHJpbmdfZGVjb2Rlcic7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uRGVwbG95bWVudHMgfSBmcm9tICcuLi9saWIvYXBpL2Nsb3VkZm9ybWF0aW9uLWRlcGxveW1lbnRzJztcbmltcG9ydCB7IENka1Rvb2xraXQgfSBmcm9tICcuLi9saWIvY2RrLXRvb2xraXQnO1xuaW1wb3J0IHsgY2xhc3NNb2NrT2YsIE1vY2tDbG91ZEV4ZWN1dGFibGUgfSBmcm9tICcuL3V0aWwnO1xuXG5sZXQgY2xvdWRFeGVjdXRhYmxlOiBNb2NrQ2xvdWRFeGVjdXRhYmxlO1xubGV0IGNsb3VkRm9ybWF0aW9uOiBqZXN0Lk1vY2tlZDxDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRzPjtcbmxldCB0b29sa2l0OiBDZGtUb29sa2l0O1xuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIGNsb3VkRXhlY3V0YWJsZSA9IG5ldyBNb2NrQ2xvdWRFeGVjdXRhYmxlKHtcbiAgICBzdGFja3M6IFt7XG4gICAgICBzdGFja05hbWU6ICdBJyxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnQScgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YWNrTmFtZTogJ0InLFxuICAgICAgZGVwZW5kczogWydBJ10sXG4gICAgICB0ZW1wbGF0ZTogeyByZXNvdXJjZTogJ0InIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGFja05hbWU6ICdDJyxcbiAgICAgIGRlcGVuZHM6IFsnQSddLFxuICAgICAgdGVtcGxhdGU6IHsgcmVzb3VyY2U6ICdDJ30sXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAnL3Jlc291cmNlJzogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGN4c2NoZW1hLkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuRVJST1IsXG4gICAgICAgICAgICBkYXRhOiAndGhpcyBpcyBhbiBlcnJvcicsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGFja05hbWU6ICdEJyxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnRCcgfSxcbiAgICB9XSxcbiAgfSk7XG5cbiAgY2xvdWRGb3JtYXRpb24gPSBjbGFzc01vY2tPZihDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRzKTtcblxuICB0b29sa2l0ID0gbmV3IENka1Rvb2xraXQoe1xuICAgIGNsb3VkRXhlY3V0YWJsZSxcbiAgICBjbG91ZEZvcm1hdGlvbixcbiAgICBjb25maWd1cmF0aW9uOiBjbG91ZEV4ZWN1dGFibGUuY29uZmlndXJhdGlvbixcbiAgICBzZGtQcm92aWRlcjogY2xvdWRFeGVjdXRhYmxlLnNka1Byb3ZpZGVyLFxuICB9KTtcblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uc1xuICBjbG91ZEZvcm1hdGlvbi5yZWFkQ3VycmVudFRlbXBsYXRlLm1vY2tJbXBsZW1lbnRhdGlvbigoc3RhY2tBcnRpZmFjdDogQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSA9PiB7XG4gICAgaWYgKHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lID09PSAnRCcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyByZXNvdXJjZTogJ0QnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgfSk7XG4gIGNsb3VkRm9ybWF0aW9uLmRlcGxveVN0YWNrLm1vY2tJbXBsZW1lbnRhdGlvbigob3B0aW9ucykgPT4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBub09wOiB0cnVlLFxuICAgIG91dHB1dHM6IHt9LFxuICAgIHN0YWNrQXJuOiAnJyxcbiAgICBzdGFja0FydGlmYWN0OiBvcHRpb25zLnN0YWNrLFxuICB9KSk7XG59KTtcblxudGVzdCgnZGlmZiBjYW4gZGlmZiBtdWx0aXBsZSBzdGFja3MnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBTdHJpbmdXcml0YWJsZSgpO1xuXG4gIC8vIFdIRU5cbiAgY29uc3QgZXhpdENvZGUgPSBhd2FpdCB0b29sa2l0LmRpZmYoe1xuICAgIHN0YWNrTmFtZXM6IFsnQiddLFxuICAgIHN0cmVhbTogYnVmZmVyLFxuICB9KTtcblxuICAvLyBUSEVOXG4gIGNvbnN0IHBsYWluVGV4dE91dHB1dCA9IGJ1ZmZlci5kYXRhLnJlcGxhY2UoL1xceDFCXFxbWzAtP10qWyAtL10qW0Atfl0vZywgJycpO1xuICBleHBlY3QocGxhaW5UZXh0T3V0cHV0KS50b0NvbnRhaW4oJ1N0YWNrIEEnKTtcbiAgZXhwZWN0KHBsYWluVGV4dE91dHB1dCkudG9Db250YWluKCdTdGFjayBCJyk7XG5cbiAgZXhwZWN0KGV4aXRDb2RlKS50b0JlKDApO1xufSk7XG5cbnRlc3QoJ2V4aXRzIHdpdGggMSB3aXRoIGRpZmZzIGFuZCBmYWlsIHNldCB0byB0cnVlJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBjb25zdCBidWZmZXIgPSBuZXcgU3RyaW5nV3JpdGFibGUoKTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGV4aXRDb2RlID0gYXdhaXQgdG9vbGtpdC5kaWZmKHtcbiAgICBzdGFja05hbWVzOiBbJ0EnXSxcbiAgICBzdHJlYW06IGJ1ZmZlcixcbiAgICBmYWlsOiB0cnVlLFxuICB9KTtcblxuICAvLyBUSEVOXG4gIGV4cGVjdChleGl0Q29kZSkudG9CZSgxKTtcbn0pO1xuXG50ZXN0KCdleGl0cyB3aXRoIDEgd2l0aCBkaWZmIGluIGZpcnN0IHN0YWNrLCBidXQgbm90IGluIHNlY29uZCBzdGFjayBhbmQgZmFpbCBzZXQgdG8gdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgYnVmZmVyID0gbmV3IFN0cmluZ1dyaXRhYmxlKCk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCBleGl0Q29kZSA9IGF3YWl0IHRvb2xraXQuZGlmZih7XG4gICAgc3RhY2tOYW1lczogWydBJywgJ0QnXSxcbiAgICBzdHJlYW06IGJ1ZmZlcixcbiAgICBmYWlsOiB0cnVlLFxuICB9KTtcblxuICAvLyBUSEVOXG4gIGV4cGVjdChleGl0Q29kZSkudG9CZSgxKTtcbn0pO1xuXG50ZXN0KCd0aHJvd3MgYW4gZXJyb3IgZHVyaW5nIGRpZmZzIG9uIHN0YWNrIHdpdGggZXJyb3IgbWV0YWRhdGEnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBTdHJpbmdXcml0YWJsZSgpO1xuXG4gIC8vIFdIRU5cbiAgdHJ5IHtcbiAgICBjb25zdCBleGl0Q29kZSA9IGF3YWl0IHRvb2xraXQuZGlmZih7XG4gICAgICBzdGFja05hbWVzOiBbJ0MnXSxcbiAgICAgIHN0cmVhbTogYnVmZmVyLFxuICAgIH0pO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChleGl0Q29kZSkudG9CZSgxKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGV4cGVjdChlLnRvU3RyaW5nKCkpLnRvQ29udGFpbignRm91bmQgZXJyb3JzJyk7XG4gIH1cbn0pO1xuXG5jbGFzcyBTdHJpbmdXcml0YWJsZSBleHRlbmRzIFdyaXRhYmxlIHtcbiAgcHVibGljIGRhdGE6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfZGVjb2RlcjogTm9kZVN0cmluZ0RlY29kZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogYW55ID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyk7XG4gICAgdGhpcy5kYXRhID0gJyc7XG4gIH1cblxuICBwdWJsaWMgX3dyaXRlKGNodW5rOiBhbnksIGVuY29kaW5nOiBzdHJpbmcsIGNhbGxiYWNrOiAoZXJyb3I/OiBFcnJvciB8IHVuZGVmaW5lZCkgPT4gdm9pZCkge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIGNodW5rID0gdGhpcy5fZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuZGF0YSArPSBjaHVuaztcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcHVibGljIF9maW5hbChjYWxsYmFjazogKGVycm9yPzogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5kYXRhICs9IHRoaXMuX2RlY29kZXIuZW5kKCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIl19