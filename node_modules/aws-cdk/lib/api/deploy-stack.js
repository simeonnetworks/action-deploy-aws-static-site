"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.destroyStack = exports.deployStack = void 0;
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors/safe");
const uuid = require("uuid");
const assets_1 = require("../assets");
const logging_1 = require("../logging");
const serialize_1 = require("../serialize");
const asset_manifest_builder_1 = require("../util/asset-manifest-builder");
const asset_publishing_1 = require("../util/asset-publishing");
const content_hash_1 = require("../util/content-hash");
const cloudformation_1 = require("./util/cloudformation");
const stack_activity_monitor_1 = require("./util/cloudformation/stack-activity-monitor");
// We need to map regions to domain suffixes, and the SDK already has a function to do this.
// It's not part of the public API, but it's also unlikely to go away.
//
// Reuse that function, and add a safety check so we don't accidentally break if they ever
// refactor that away.
/* eslint-disable @typescript-eslint/no-require-imports */
const regionUtil = require('aws-sdk/lib/region_config');
/* eslint-enable @typescript-eslint/no-require-imports */
if (!regionUtil.getEndpointSuffix) {
    throw new Error('This version of AWS SDK for JS does not have the \'getEndpointSuffix\' function!');
}
const LARGE_TEMPLATE_SIZE_KB = 50;
/** @experimental */
async function deployStack(options) {
    var _a, _b;
    const stackArtifact = options.stack;
    const stackEnv = options.resolvedEnvironment;
    const cfn = options.sdk.cloudFormation();
    const deployName = options.deployName || stackArtifact.stackName;
    let cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (cloudFormationStack.stackStatus.isCreationFailure) {
        logging_1.debug(`Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`);
        await cfn.deleteStack({ StackName: deployName }).promise();
        const deletedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (deletedStack && deletedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`);
        }
        // Update variable to mark that the stack does not exist anymore, but avoid
        // doing an actual lookup in CloudFormation (which would be silly to do if
        // we just deleted it).
        cloudFormationStack = cloudformation_1.CloudFormationStack.doesNotExist(cfn, deployName);
    }
    // Detect "legacy" assets (which remain in the metadata) and publish them via
    // an ad-hoc asset manifest, while passing their locations via template
    // parameters.
    const legacyAssets = new asset_manifest_builder_1.AssetManifestBuilder();
    const assetParams = await assets_1.addMetadataAssetsToManifest(stackArtifact, legacyAssets, options.toolkitInfo, options.reuseAssets);
    const finalParameterValues = { ...options.parameters, ...assetParams };
    const templateParams = cloudformation_1.TemplateParameters.fromTemplate(stackArtifact.template);
    const stackParams = options.usePreviousParameters
        ? templateParams.diff(finalParameterValues, cloudFormationStack.parameters)
        : templateParams.toStackParameters(finalParameterValues);
    if (await canSkipDeploy(options, cloudFormationStack, stackParams)) {
        logging_1.debug(`${deployName}: skipping deployment (use --force to override)`);
        return {
            noOp: true,
            outputs: cloudFormationStack.outputs,
            stackArn: cloudFormationStack.stackId,
            stackArtifact,
        };
    }
    else {
        logging_1.debug(`${deployName}: deploying...`);
    }
    const executionId = uuid.v4();
    const bodyParameter = await makeBodyParameter(stackArtifact, options.resolvedEnvironment, legacyAssets, options.toolkitInfo);
    await asset_publishing_1.publishAssets(legacyAssets.toManifest(stackArtifact.assembly.directory), options.sdkProvider, stackEnv);
    const changeSetName = `CDK-${executionId}`;
    const update = cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== 'REVIEW_IN_PROGRESS';
    logging_1.debug(`Attempting to create ChangeSet ${changeSetName} to ${update ? 'update' : 'create'} stack ${deployName}`);
    logging_1.print('%s: creating CloudFormation changeset...', colors.bold(deployName));
    const changeSet = await cfn.createChangeSet({
        StackName: deployName,
        ChangeSetName: changeSetName,
        ChangeSetType: update ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for execution ${executionId}`,
        TemplateBody: bodyParameter.TemplateBody,
        TemplateURL: bodyParameter.TemplateURL,
        Parameters: stackParams.apiParameters,
        RoleARN: options.roleArn,
        NotificationARNs: options.notificationArns,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
        Tags: options.tags,
    }).promise();
    logging_1.debug('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    const changeSetDescription = await cloudformation_1.waitForChangeSet(cfn, deployName, changeSetName);
    // Update termination protection only if it has changed.
    const terminationProtection = (_a = stackArtifact.terminationProtection) !== null && _a !== void 0 ? _a : false;
    if (!!cloudFormationStack.terminationProtection !== terminationProtection) {
        logging_1.debug('Updating termination protection from %s to %s for stack %s', cloudFormationStack.terminationProtection, terminationProtection, deployName);
        await cfn.updateTerminationProtection({
            StackName: deployName,
            EnableTerminationProtection: terminationProtection,
        }).promise();
        logging_1.debug('Termination protection updated to %s for stack %s', terminationProtection, deployName);
    }
    if (cloudformation_1.changeSetHasNoChanges(changeSetDescription)) {
        logging_1.debug('No changes are to be performed on %s.', deployName);
        await cfn.deleteChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
        return { noOp: true, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId, stackArtifact };
    }
    const execute = options.execute === undefined ? true : options.execute;
    if (execute) {
        logging_1.debug('Initiating execution of changeset %s on stack %s', changeSetName, deployName);
        await cfn.executeChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
        // eslint-disable-next-line max-len
        const monitor = options.quiet ? undefined : new stack_activity_monitor_1.StackActivityMonitor(cfn, deployName, stackArtifact, {
            resourcesTotal: ((_b = changeSetDescription.Changes) !== null && _b !== void 0 ? _b : []).length,
        }).start();
        logging_1.debug('Execution of changeset %s on stack %s has started; waiting for the update to complete...', changeSetName, deployName);
        try {
            const finalStack = await cloudformation_1.waitForStackDeploy(cfn, deployName);
            // This shouldn't really happen, but catch it anyway. You never know.
            if (!finalStack) {
                throw new Error('Stack deploy failed (the stack disappeared while we were deploying it)');
            }
            cloudFormationStack = finalStack;
        }
        finally {
            await (monitor === null || monitor === void 0 ? void 0 : monitor.stop());
        }
        logging_1.debug('Stack %s has completed updating', deployName);
    }
    else {
        logging_1.print('Changeset %s created and waiting in review for manual execution (--no-execute)', changeSetName);
    }
    return { noOp: false, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId, stackArtifact };
}
exports.deployStack = deployStack;
/**
 * Prepares the body parameter for +CreateChangeSet+.
 *
 * If the template is small enough to be inlined into the API call, just return
 * it immediately.
 *
 * Otherwise, add it to the asset manifest to get uploaded to the staging
 * bucket and return its coordinates. If there is no staging bucket, an error
 * is thrown.
 *
 * @param stack     the synthesized stack that provides the CloudFormation template
 * @param toolkitInfo information about the toolkit stack
 */
async function makeBodyParameter(stack, resolvedEnvironment, assetManifest, toolkitInfo) {
    // If the template has already been uploaded to S3, just use it from there.
    if (stack.stackTemplateAssetObjectUrl) {
        return { TemplateURL: restUrlFromManifest(stack.stackTemplateAssetObjectUrl, resolvedEnvironment) };
    }
    // Otherwise, pass via API call (if small) or upload here (if large)
    const templateJson = serialize_1.toYAML(stack.template);
    if (templateJson.length <= LARGE_TEMPLATE_SIZE_KB * 1024) {
        return { TemplateBody: templateJson };
    }
    if (!toolkitInfo) {
        logging_1.error(`The template for stack "${stack.displayName}" is ${Math.round(templateJson.length / 1024)}KiB. ` +
            `Templates larger than ${LARGE_TEMPLATE_SIZE_KB}KiB must be uploaded to S3.\n` +
            'Run the following command in order to setup an S3 bucket in this environment, and then re-deploy:\n\n', colors.blue(`\t$ cdk bootstrap ${resolvedEnvironment.name}\n`));
        throw new Error('Template too large to deploy ("cdk bootstrap" is required)');
    }
    const templateHash = content_hash_1.contentHash(templateJson);
    const key = `cdk/${stack.id}/${templateHash}.yml`;
    assetManifest.addFileAsset(templateHash, {
        path: stack.templateFile,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    const templateURL = `${toolkitInfo.bucketUrl}/${key}`;
    logging_1.debug('Storing template in S3 at:', templateURL);
    return { TemplateURL: templateURL };
}
/** @experimental */
async function destroyStack(options) {
    const deployName = options.deployName || options.stack.stackName;
    const cfn = options.sdk.cloudFormation();
    const currentStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (!currentStack.exists) {
        return;
    }
    const monitor = options.quiet ? undefined : new stack_activity_monitor_1.StackActivityMonitor(cfn, deployName, options.stack).start();
    try {
        await cfn.deleteStack({ StackName: deployName, RoleARN: options.roleArn }).promise();
        const destroyedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (destroyedStack && destroyedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed to destroy ${deployName}: ${destroyedStack.stackStatus}`);
        }
    }
    finally {
        if (monitor) {
            await monitor.stop();
        }
    }
}
exports.destroyStack = destroyStack;
/**
 * Checks whether we can skip deployment
 *
 * We do this in a complicated way by preprocessing (instead of just
 * looking at the changeset), because if there are nested stacks involved
 * the changeset will always show the nested stacks as needing to be
 * updated, and the deployment will take a long time to in effect not
 * do anything.
 */
async function canSkipDeploy(deployStackOptions, cloudFormationStack, params) {
    var _a;
    const deployName = deployStackOptions.deployName || deployStackOptions.stack.stackName;
    logging_1.debug(`${deployName}: checking if we can skip deploy`);
    // Forced deploy
    if (deployStackOptions.force) {
        logging_1.debug(`${deployName}: forced deployment`);
        return false;
    }
    // No existing stack
    if (!cloudFormationStack.exists) {
        logging_1.debug(`${deployName}: no existing stack`);
        return false;
    }
    // Template has changed (assets taken into account here)
    if (JSON.stringify(deployStackOptions.stack.template) !== JSON.stringify(await cloudFormationStack.template())) {
        logging_1.debug(`${deployName}: template has changed`);
        return false;
    }
    // Tags have changed
    if (!compareTags(cloudFormationStack.tags, (_a = deployStackOptions.tags) !== null && _a !== void 0 ? _a : [])) {
        logging_1.debug(`${deployName}: tags have changed`);
        return false;
    }
    // Termination protection has been updated
    if (!!deployStackOptions.stack.terminationProtection !== !!cloudFormationStack.terminationProtection) {
        logging_1.debug(`${deployName}: termination protection has been updated`);
        return false;
    }
    // Parameters have changed
    if (params.changed) {
        logging_1.debug(`${deployName}: parameters have changed`);
        return false;
    }
    // We can skip deploy
    return true;
}
/**
 * Compares two list of tags, returns true if identical.
 */
function compareTags(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (const aTag of a) {
        const bTag = b.find(tag => tag.Key === aTag.Key);
        if (!bTag || bTag.Value !== aTag.Value) {
            return false;
        }
    }
    return true;
}
/**
 * Format an S3 URL in the manifest for use with CloudFormation
 *
 * Replaces environment placeholders (which this field may contain),
 * and reformats s3://.../... urls into S3 REST URLs (which CloudFormation
 * expects)
 */
function restUrlFromManifest(url, environment) {
    const doNotUseMarker = '**DONOTUSE**';
    // This URL may contain placeholders, so still substitute those.
    url = cxapi.EnvironmentPlaceholders.replace(url, {
        accountId: environment.account,
        region: environment.region,
        partition: doNotUseMarker,
    });
    // Yes, this is extremely crude, but we don't actually need this so I'm not inclined to spend
    // a lot of effort trying to thread the right value to this location.
    if (url.indexOf(doNotUseMarker) > -1) {
        throw new Error('Cannot use \'${AWS::Partition}\' in the \'stackTemplateAssetObjectUrl\' field');
    }
    const s3Url = url.match(/s3:\/\/([^/]+)\/(.*)$/);
    if (!s3Url) {
        return url;
    }
    // We need to pass an 'https://s3.REGION.amazonaws.com[.cn]/bucket/object' URL to CloudFormation, but we
    // got an 's3://bucket/object' URL instead. Construct the rest API URL here.
    const bucketName = s3Url[1];
    const objectKey = s3Url[2];
    const urlSuffix = regionUtil.getEndpointSuffix(environment.region);
    return `https://s3.${environment.region}.${urlSuffix}/${bucketName}/${objectKey}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGVwbG95LXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUF5QztBQUN6QyxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLHNDQUF3RDtBQUV4RCx3Q0FBaUQ7QUFDakQsNENBQXNDO0FBQ3RDLDJFQUFzRTtBQUN0RSwrREFBeUQ7QUFDekQsdURBQW1EO0FBR25ELDBEQUFrTDtBQUNsTCx5RkFBb0Y7QUFFcEYsNEZBQTRGO0FBQzVGLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0YsMEZBQTBGO0FBQzFGLHNCQUFzQjtBQUV0QiwwREFBMEQ7QUFDMUQsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFDeEQseURBQXlEO0FBRXpELElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUU7SUFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRkFBa0YsQ0FBQyxDQUFDO0NBQ3JHO0FBdUlELE1BQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDO0FBRWxDLG9CQUFvQjtBQUNiLEtBQUssVUFBVSxXQUFXLENBQUMsT0FBMkI7O0lBQzNELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFFcEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDO0lBRTdDLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDekMsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDO0lBQ2pFLElBQUksbUJBQW1CLEdBQUcsTUFBTSxvQ0FBbUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTVFLElBQUksbUJBQW1CLENBQUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFO1FBQ3JELGVBQUssQ0FBQyx3QkFBd0IsVUFB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QixNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFM0IsTUFBTSxTQUFTLEdBQVcsVUFBVSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRSxPQUFPLGNBQWMsV0FBVyxDQUFDLE1BQU0sSUFBSSxTQUFTLElBQUksVUFBVSxJQUFJLFNBQVMsRUFBRSxDQUFDO0FBQ3BGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9ycy9zYWZlJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBhZGRNZXRhZGF0YUFzc2V0c1RvTWFuaWZlc3QgfSBmcm9tICcuLi9hc3NldHMnO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnLi4vY2RrLXRvb2xraXQnO1xuaW1wb3J0IHsgZGVidWcsIGVycm9yLCBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgdG9ZQU1MIH0gZnJvbSAnLi4vc2VyaWFsaXplJztcbmltcG9ydCB7IEFzc2V0TWFuaWZlc3RCdWlsZGVyIH0gZnJvbSAnLi4vdXRpbC9hc3NldC1tYW5pZmVzdC1idWlsZGVyJztcbmltcG9ydCB7IHB1Ymxpc2hBc3NldHMgfSBmcm9tICcuLi91dGlsL2Fzc2V0LXB1Ymxpc2hpbmcnO1xuaW1wb3J0IHsgY29udGVudEhhc2ggfSBmcm9tICcuLi91dGlsL2NvbnRlbnQtaGFzaCc7XG5pbXBvcnQgeyBJU0RLLCBTZGtQcm92aWRlciB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMsIENsb3VkRm9ybWF0aW9uU3RhY2ssIFN0YWNrUGFyYW1ldGVycywgVGVtcGxhdGVQYXJhbWV0ZXJzLCB3YWl0Rm9yQ2hhbmdlU2V0LCB3YWl0Rm9yU3RhY2tEZXBsb3ksIHdhaXRGb3JTdGFja0RlbGV0ZSB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5TW9uaXRvciB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbi9zdGFjay1hY3Rpdml0eS1tb25pdG9yJztcblxuLy8gV2UgbmVlZCB0byBtYXAgcmVnaW9ucyB0byBkb21haW4gc3VmZml4ZXMsIGFuZCB0aGUgU0RLIGFscmVhZHkgaGFzIGEgZnVuY3Rpb24gdG8gZG8gdGhpcy5cbi8vIEl0J3Mgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIGJ1dCBpdCdzIGFsc28gdW5saWtlbHkgdG8gZ28gYXdheS5cbi8vXG4vLyBSZXVzZSB0aGF0IGZ1bmN0aW9uLCBhbmQgYWRkIGEgc2FmZXR5IGNoZWNrIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBicmVhayBpZiB0aGV5IGV2ZXJcbi8vIHJlZmFjdG9yIHRoYXQgYXdheS5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgcmVnaW9uVXRpbCA9IHJlcXVpcmUoJ2F3cy1zZGsvbGliL3JlZ2lvbl9jb25maWcnKTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuXG5pZiAoIXJlZ2lvblV0aWwuZ2V0RW5kcG9pbnRTdWZmaXgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHZlcnNpb24gb2YgQVdTIFNESyBmb3IgSlMgZG9lcyBub3QgaGF2ZSB0aGUgXFwnZ2V0RW5kcG9pbnRTdWZmaXhcXCcgZnVuY3Rpb24hJyk7XG59XG5cbnR5cGUgVGVtcGxhdGVCb2R5UGFyYW1ldGVyID0ge1xuICBUZW1wbGF0ZUJvZHk/OiBzdHJpbmdcbiAgVGVtcGxhdGVVUkw/OiBzdHJpbmdcbn07XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrUmVzdWx0IHtcbiAgcmVhZG9ubHkgbm9PcDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgb3V0cHV0czogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHJlYWRvbmx5IHN0YWNrQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbn1cblxuLyoqIEBleHBlcmltZW50YWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVwbG95U3RhY2tPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBzdGFjayB0byBiZSBkZXBsb3llZFxuICAgKi9cbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcblxuICAvKipcbiAgICogVGhlIGVudmlyb25tZW50IHRvIGRlcGxveSB0aGlzIHN0YWNrIGluXG4gICAqXG4gICAqIFRoZSBlbnZpcm9ubWVudCBvbiB0aGUgc3RhY2sgYXJ0aWZhY3QgbWF5IGJlIHVucmVzb2x2ZWQsIHRoaXMgb25lXG4gICAqIG11c3QgYmUgcmVzb2x2ZWQuXG4gICAqL1xuICByZXNvbHZlZEVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudDtcblxuICAvKipcbiAgICogVGhlIFNESyB0byB1c2UgZm9yIGRlcGxveWluZyB0aGUgc3RhY2tcbiAgICpcbiAgICogU2hvdWxkIGhhdmUgYmVlbiBpbml0aWFsaXplZCB3aXRoIHRoZSBjb3JyZWN0IHJvbGUgd2l0aCB3aGljaFxuICAgKiBzdGFjayBvcGVyYXRpb25zIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gICAqL1xuICBzZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIFNESyBwcm92aWRlciAoc2VlZGVkIHdpdGggZGVmYXVsdCBjcmVkZW50aWFscylcbiAgICpcbiAgICogV2lsbCBleGNsdXNpdmVseSBiZSB1c2VkIHRvIGFzc3VtZSBwdWJsaXNoaW5nIGNyZWRlbnRpYWxzICh3aGljaCBtdXN0XG4gICAqIHN0YXJ0IG91dCBmcm9tIGN1cnJlbnQgY3JlZGVudGlhbHMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlJ3ZlIGFzc3VtZWQgYW5cbiAgICogYWN0aW9uIHJvbGUgdG8gdG91Y2ggdGhlIHN0YWNrIG9yIG5vdCkuXG4gICAqXG4gICAqIFVzZWQgZm9yIHRoZSBmb2xsb3dpbmcgcHVycG9zZXM6XG4gICAqXG4gICAqIC0gUHVibGlzaCBsZWdhY3kgYXNzZXRzLlxuICAgKiAtIFVwbG9hZCBsYXJnZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZXMgdG8gdGhlIHN0YWdpbmcgYnVja2V0LlxuICAgKi9cbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuXG4gIC8qKlxuICAgKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgYm9vdHN0cmFwIHN0YWNrIGZvdW5kIGluIHRoZSB0YXJnZXQgZW52aXJvbm1lbnRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBBc3N1bWUgdGhlcmUgaXMgbm8gYm9vdHN0cmFwIHN0YWNrXG4gICAqL1xuICB0b29sa2l0SW5mbz86IFRvb2xraXRJbmZvO1xuXG4gIC8qKlxuICAgKiBSb2xlIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gdG8gZXhlY3V0ZSB0aGUgY2hhbmdlIHNldFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFJvbGUgc3BlY2lmaWVkIG9uIHN0YWNrLCBvdGhlcndpc2UgY3VycmVudFxuICAgKi9cbiAgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIEFSTnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiB0byBub3RpZnkgd2hlbiB0aGUgY2hhbmdlIHNldCBoYXMgY29tcGxldGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gbm90aWZpY2F0aW9uc1xuICAgKi9cbiAgbm90aWZpY2F0aW9uQXJucz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOYW1lIHRvIGRlcGxveSB0aGUgc3RhY2sgdW5kZXJcbiAgICpcbiAgICogQGRlZmF1bHQgLSBOYW1lIGZyb20gYXNzZW1ibHlcbiAgICovXG4gIGRlcGxveU5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFF1aWV0IG9yIHZlcmJvc2UgZGVwbG95bWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcXVpZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IElEcyB3aGljaCBzaG91bGRuJ3QgYmUgYnVpbHRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBCdWlsZCBhbGwgYXNzZXRzXG4gICAqL1xuICByZXVzZUFzc2V0cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUYWdzIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gdG8gYWRkIHRvIHN0YWNrXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFnc1xuICAgKi9cbiAgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIGNoYW5nZXNldCBvciBsZWF2ZSBpdCBpbiByZXZpZXcuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGV4ZWN1dGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgY29sbGVjdGlvbiBvZiBleHRyYSBwYXJhbWV0ZXJzXG4gICAqIChpbiBhZGRpdGlvbiB0byB0aG9zZSB1c2VkIGZvciBhc3NldHMpXG4gICAqIHRvIHBhc3MgdG8gdGhlIGRlcGxveWVkIHRlbXBsYXRlLlxuICAgKiBOb3RlIHRoYXQgcGFyYW1ldGVycyB3aXRoIGB1bmRlZmluZWRgIG9yIGVtcHR5IHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQsXG4gICAqIGFuZCBub3QgcGFzc2VkIHRvIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlbXBsYXRlXG4gICAqL1xuICBwYXJhbWV0ZXJzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERlcGxveSBldmVuIGlmIHRoZSBkZXBsb3llZCB0ZW1wbGF0ZSBpcyBpZGVudGljYWwgdG8gdGhlIG9uZSB3ZSBhcmUgYWJvdXQgdG8gZGVwbG95LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZm9yY2U/OiBib29sZWFuO1xufVxuXG5jb25zdCBMQVJHRV9URU1QTEFURV9TSVpFX0tCID0gNTA7XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVwbG95U3RhY2sob3B0aW9uczogRGVwbG95U3RhY2tPcHRpb25zKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICBjb25zdCBzdGFja0FydGlmYWN0ID0gb3B0aW9ucy5zdGFjaztcblxuICBjb25zdCBzdGFja0VudiA9IG9wdGlvbnMucmVzb2x2ZWRFbnZpcm9ubWVudDtcblxuICBjb25zdCBjZm4gPSBvcHRpb25zLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5kZXBsb3lOYW1lIHx8IHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lO1xuICBsZXQgY2xvdWRGb3JtYXRpb25TdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgZGVwbG95TmFtZSk7XG5cbiAgaWYgKGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICBkZWJ1ZyhgRm91bmQgZXhpc3Rpbmcgc3RhY2sgJHtkZXBsb3lOYW1lfSB0aGF0IGhhZCBwcmV2aW91c2x5IGZhaWxlZCBjcmVhdGlvbi4gRGVsZXRpbmcgaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmUtY3JlYXRlIGl0LmApO1xuICAgIGF3YWl0IGNmbi5kZWxldGVTdGFjayh7IFN0YWNrTmFtZTogZGVwbG95TmFtZSB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgZGVsZXRlZFN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrRGVsZXRlKGNmbiwgZGVwbG95TmFtZSk7XG4gICAgaWYgKGRlbGV0ZWRTdGFjayAmJiBkZWxldGVkU3RhY2suc3RhY2tTdGF0dXMubmFtZSAhPT0gJ0RFTEVURV9DT01QTEVURScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGRlbGV0aW5nIHN0YWNrICR7ZGVwbG95TmFtZX0gdGhhdCBoYWQgcHJldmlvdXNseSBmYWlsZWQgY3JlYXRpb24gKGN1cnJlbnQgc3RhdGU6ICR7ZGVsZXRlZFN0YWNrLnN0YWNrU3RhdHVzfSlgKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHZhcmlhYmxlIHRvIG1hcmsgdGhhdCB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QgYW55bW9yZSwgYnV0IGF2b2lkXG4gICAgLy8gZG9pbmcgYW4gYWN0dWFsIGxvb2t1cCBpbiBDbG91ZEZvcm1hdGlvbiAod2hpY2ggd291bGQgYmUgc2lsbHkgdG8gZG8gaWZcbiAgICAvLyB3ZSBqdXN0IGRlbGV0ZWQgaXQpLlxuICAgIGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBDbG91ZEZvcm1hdGlvblN0YWNrLmRvZXNOb3RFeGlzdChjZm4sIGRlcGxveU5hbWUpO1xuICB9XG5cbiAgLy8gRGV0ZWN0IFwibGVnYWN5XCIgYXNzZXRzICh3aGljaCByZW1haW4gaW4gdGhlIG1ldGFkYXRhKSBhbmQgcHVibGlzaCB0aGVtIHZpYVxuICAvLyBhbiBhZC1ob2MgYXNzZXQgbWFuaWZlc3QsIHdoaWxlIHBhc3NpbmcgdGhlaXIgbG9jYXRpb25zIHZpYSB0ZW1wbGF0ZVxuICAvLyBwYXJhbWV0ZXJzLlxuICBjb25zdCBsZWdhY3lBc3NldHMgPSBuZXcgQXNzZXRNYW5pZmVzdEJ1aWxkZXIoKTtcbiAgY29uc3QgYXNzZXRQYXJhbXMgPSBhd2FpdCBhZGRNZXRhZGF0YUFzc2V0c1RvTWFuaWZlc3Qoc3RhY2tBcnRpZmFjdCwgbGVnYWN5QXNzZXRzLCBvcHRpb25zLnRvb2xraXRJbmZvLCBvcHRpb25zLnJldXNlQXNzZXRzKTtcblxuICBjb25zdCBmaW5hbFBhcmFtZXRlclZhbHVlcyA9IHsgLi4ub3B0aW9ucy5wYXJhbWV0ZXJzLCAuLi5hc3NldFBhcmFtcyB9O1xuXG4gIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZShzdGFja0FydGlmYWN0LnRlbXBsYXRlKTtcbiAgY29uc3Qgc3RhY2tQYXJhbXMgPSBvcHRpb25zLnVzZVByZXZpb3VzUGFyYW1ldGVyc1xuICAgID8gdGVtcGxhdGVQYXJhbXMuZGlmZihmaW5hbFBhcmFtZXRlclZhbHVlcywgY2xvdWRGb3JtYXRpb25TdGFjay5wYXJhbWV0ZXJzKVxuICAgIDogdGVtcGxhdGVQYXJhbXMudG9TdGFja1BhcmFtZXRlcnMoZmluYWxQYXJhbWV0ZXJWYWx1ZXMpO1xuXG4gIGlmIChhd2FpdCBjYW5Ta2lwRGVwbG95KG9wdGlvbnMsIGNsb3VkRm9ybWF0aW9uU3RhY2ssIHN0YWNrUGFyYW1zKSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBza2lwcGluZyBkZXBsb3ltZW50ICh1c2UgLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9PcDogdHJ1ZSxcbiAgICAgIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cyxcbiAgICAgIHN0YWNrQXJuOiBjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrSWQsXG4gICAgICBzdGFja0FydGlmYWN0LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IGRlcGxveWluZy4uLmApO1xuICB9XG5cbiAgY29uc3QgZXhlY3V0aW9uSWQgPSB1dWlkLnY0KCk7XG4gIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihzdGFja0FydGlmYWN0LCBvcHRpb25zLnJlc29sdmVkRW52aXJvbm1lbnQsIGxlZ2FjeUFzc2V0cywgb3B0aW9ucy50b29sa2l0SW5mbyk7XG5cbiAgYXdhaXQgcHVibGlzaEFzc2V0cyhsZWdhY3lBc3NldHMudG9NYW5pZmVzdChzdGFja0FydGlmYWN0LmFzc2VtYmx5LmRpcmVjdG9yeSksIG9wdGlvbnMuc2RrUHJvdmlkZXIsIHN0YWNrRW52KTtcblxuICBjb25zdCBjaGFuZ2VTZXROYW1lID0gYENESy0ke2V4ZWN1dGlvbklkfWA7XG4gIGNvbnN0IHVwZGF0ZSA9IGNsb3VkRm9ybWF0aW9uU3RhY2suZXhpc3RzICYmIGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMubmFtZSAhPT0gJ1JFVklFV19JTl9QUk9HUkVTUyc7XG5cbiAgZGVidWcoYEF0dGVtcHRpbmcgdG8gY3JlYXRlIENoYW5nZVNldCAke2NoYW5nZVNldE5hbWV9IHRvICR7dXBkYXRlID8gJ3VwZGF0ZScgOiAnY3JlYXRlJ30gc3RhY2sgJHtkZXBsb3lOYW1lfWApO1xuICBwcmludCgnJXM6IGNyZWF0aW5nIENsb3VkRm9ybWF0aW9uIGNoYW5nZXNldC4uLicsIGNvbG9ycy5ib2xkKGRlcGxveU5hbWUpKTtcbiAgY29uc3QgY2hhbmdlU2V0ID0gYXdhaXQgY2ZuLmNyZWF0ZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLFxuICAgIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUsXG4gICAgQ2hhbmdlU2V0VHlwZTogdXBkYXRlID8gJ1VQREFURScgOiAnQ1JFQVRFJyxcbiAgICBEZXNjcmlwdGlvbjogYENESyBDaGFuZ2VzZXQgZm9yIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfWAsXG4gICAgVGVtcGxhdGVCb2R5OiBib2R5UGFyYW1ldGVyLlRlbXBsYXRlQm9keSxcbiAgICBUZW1wbGF0ZVVSTDogYm9keVBhcmFtZXRlci5UZW1wbGF0ZVVSTCxcbiAgICBQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLFxuICAgIFJvbGVBUk46IG9wdGlvbnMucm9sZUFybixcbiAgICBOb3RpZmljYXRpb25BUk5zOiBvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMsXG4gICAgQ2FwYWJpbGl0aWVzOiBbICdDQVBBQklMSVRZX0lBTScsICdDQVBBQklMSVRZX05BTUVEX0lBTScsICdDQVBBQklMSVRZX0FVVE9fRVhQQU5EJyBdLFxuICAgIFRhZ3M6IG9wdGlvbnMudGFncyxcbiAgfSkucHJvbWlzZSgpO1xuICBkZWJ1ZygnSW5pdGlhdGVkIGNyZWF0aW9uIG9mIGNoYW5nZXNldDogJXM7IHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldC5JZCk7XG4gIGNvbnN0IGNoYW5nZVNldERlc2NyaXB0aW9uID0gYXdhaXQgd2FpdEZvckNoYW5nZVNldChjZm4sIGRlcGxveU5hbWUsIGNoYW5nZVNldE5hbWUpO1xuXG4gIC8vIFVwZGF0ZSB0ZXJtaW5hdGlvbiBwcm90ZWN0aW9uIG9ubHkgaWYgaXQgaGFzIGNoYW5nZWQuXG4gIGNvbnN0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbiA9IHN0YWNrQXJ0aWZhY3QudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGZhbHNlO1xuICBpZiAoISFjbG91ZEZvcm1hdGlvblN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiAhPT0gdGVybWluYXRpb25Qcm90ZWN0aW9uKSB7XG4gICAgZGVidWcoJ1VwZGF0aW5nIHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gZnJvbSAlcyB0byAlcyBmb3Igc3RhY2sgJXMnLCBjbG91ZEZvcm1hdGlvblN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiwgdGVybWluYXRpb25Qcm90ZWN0aW9uLCBkZXBsb3lOYW1lKTtcbiAgICBhd2FpdCBjZm4udXBkYXRlVGVybWluYXRpb25Qcm90ZWN0aW9uKHtcbiAgICAgIFN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICAgIEVuYWJsZVRlcm1pbmF0aW9uUHJvdGVjdGlvbjogdGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgIH0pLnByb21pc2UoKTtcbiAgICBkZWJ1ZygnVGVybWluYXRpb24gcHJvdGVjdGlvbiB1cGRhdGVkIHRvICVzIGZvciBzdGFjayAlcycsIHRlcm1pbmF0aW9uUHJvdGVjdGlvbiwgZGVwbG95TmFtZSk7XG4gIH1cblxuICBpZiAoY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGNoYW5nZVNldERlc2NyaXB0aW9uKSkge1xuICAgIGRlYnVnKCdObyBjaGFuZ2VzIGFyZSB0byBiZSBwZXJmb3JtZWQgb24gJXMuJywgZGVwbG95TmFtZSk7XG4gICAgYXdhaXQgY2ZuLmRlbGV0ZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogZGVwbG95TmFtZSwgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIHsgbm9PcDogdHJ1ZSwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLCBzdGFja0FybjogY2hhbmdlU2V0LlN0YWNrSWQhLCBzdGFja0FydGlmYWN0IH07XG4gIH1cblxuICBjb25zdCBleGVjdXRlID0gb3B0aW9ucy5leGVjdXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5leGVjdXRlO1xuICBpZiAoZXhlY3V0ZSkge1xuICAgIGRlYnVnKCdJbml0aWF0aW5nIGV4ZWN1dGlvbiBvZiBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMnLCBjaGFuZ2VTZXROYW1lLCBkZXBsb3lOYW1lKTtcbiAgICBhd2FpdCBjZm4uZXhlY3V0ZUNoYW5nZVNldCh7U3RhY2tOYW1lOiBkZXBsb3lOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lfSkucHJvbWlzZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgY29uc3QgbW9uaXRvciA9IG9wdGlvbnMucXVpZXQgPyB1bmRlZmluZWQgOiBuZXcgU3RhY2tBY3Rpdml0eU1vbml0b3IoY2ZuLCBkZXBsb3lOYW1lLCBzdGFja0FydGlmYWN0LCB7XG4gICAgICByZXNvdXJjZXNUb3RhbDogKGNoYW5nZVNldERlc2NyaXB0aW9uLkNoYW5nZXMgPz8gW10pLmxlbmd0aCxcbiAgICB9KS5zdGFydCgpO1xuICAgIGRlYnVnKCdFeGVjdXRpb24gb2YgY2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIGhhcyBzdGFydGVkOyB3YWl0aW5nIGZvciB0aGUgdXBkYXRlIHRvIGNvbXBsZXRlLi4uJywgY2hhbmdlU2V0TmFtZSwgZGVwbG95TmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbmFsU3RhY2sgPSBhd2FpdCB3YWl0Rm9yU3RhY2tEZXBsb3koY2ZuLCBkZXBsb3lOYW1lKTtcblxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiwgYnV0IGNhdGNoIGl0IGFueXdheS4gWW91IG5ldmVyIGtub3cuXG4gICAgICBpZiAoIWZpbmFsU3RhY2spIHsgdGhyb3cgbmV3IEVycm9yKCdTdGFjayBkZXBsb3kgZmFpbGVkICh0aGUgc3RhY2sgZGlzYXBwZWFyZWQgd2hpbGUgd2Ugd2VyZSBkZXBsb3lpbmcgaXQpJyk7IH1cbiAgICAgIGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBmaW5hbFN0YWNrO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBtb25pdG9yPy5zdG9wKCk7XG4gICAgfVxuICAgIGRlYnVnKCdTdGFjayAlcyBoYXMgY29tcGxldGVkIHVwZGF0aW5nJywgZGVwbG95TmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnQoJ0NoYW5nZXNldCAlcyBjcmVhdGVkIGFuZCB3YWl0aW5nIGluIHJldmlldyBmb3IgbWFudWFsIGV4ZWN1dGlvbiAoLS1uby1leGVjdXRlKScsIGNoYW5nZVNldE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHsgbm9PcDogZmFsc2UsIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cywgc3RhY2tBcm46IGNoYW5nZVNldC5TdGFja0lkISwgc3RhY2tBcnRpZmFjdCB9O1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBib2R5IHBhcmFtZXRlciBmb3IgK0NyZWF0ZUNoYW5nZVNldCsuXG4gKlxuICogSWYgdGhlIHRlbXBsYXRlIGlzIHNtYWxsIGVub3VnaCB0byBiZSBpbmxpbmVkIGludG8gdGhlIEFQSSBjYWxsLCBqdXN0IHJldHVyblxuICogaXQgaW1tZWRpYXRlbHkuXG4gKlxuICogT3RoZXJ3aXNlLCBhZGQgaXQgdG8gdGhlIGFzc2V0IG1hbmlmZXN0IHRvIGdldCB1cGxvYWRlZCB0byB0aGUgc3RhZ2luZ1xuICogYnVja2V0IGFuZCByZXR1cm4gaXRzIGNvb3JkaW5hdGVzLiBJZiB0aGVyZSBpcyBubyBzdGFnaW5nIGJ1Y2tldCwgYW4gZXJyb3JcbiAqIGlzIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gc3RhY2sgICAgIHRoZSBzeW50aGVzaXplZCBzdGFjayB0aGF0IHByb3ZpZGVzIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICogQHBhcmFtIHRvb2xraXRJbmZvIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0b29sa2l0IHN0YWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VCb2R5UGFyYW1ldGVyKFxuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICByZXNvbHZlZEVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIHRvb2xraXRJbmZvPzogVG9vbGtpdEluZm8pOiBQcm9taXNlPFRlbXBsYXRlQm9keVBhcmFtZXRlcj4ge1xuXG4gIC8vIElmIHRoZSB0ZW1wbGF0ZSBoYXMgYWxyZWFkeSBiZWVuIHVwbG9hZGVkIHRvIFMzLCBqdXN0IHVzZSBpdCBmcm9tIHRoZXJlLlxuICBpZiAoc3RhY2suc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsKSB7XG4gICAgcmV0dXJuIHsgVGVtcGxhdGVVUkw6IHJlc3RVcmxGcm9tTWFuaWZlc3Qoc3RhY2suc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsLCByZXNvbHZlZEVudmlyb25tZW50KSB9O1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBwYXNzIHZpYSBBUEkgY2FsbCAoaWYgc21hbGwpIG9yIHVwbG9hZCBoZXJlIChpZiBsYXJnZSlcbiAgY29uc3QgdGVtcGxhdGVKc29uID0gdG9ZQU1MKHN0YWNrLnRlbXBsYXRlKTtcblxuICBpZiAodGVtcGxhdGVKc29uLmxlbmd0aCA8PSBMQVJHRV9URU1QTEFURV9TSVpFX0tCICogMTAyNCkge1xuICAgIHJldHVybiB7IFRlbXBsYXRlQm9keTogdGVtcGxhdGVKc29uIH07XG4gIH1cblxuICBpZiAoIXRvb2xraXRJbmZvKSB7XG4gICAgZXJyb3IoXG4gICAgICBgVGhlIHRlbXBsYXRlIGZvciBzdGFjayBcIiR7c3RhY2suZGlzcGxheU5hbWV9XCIgaXMgJHtNYXRoLnJvdW5kKHRlbXBsYXRlSnNvbi5sZW5ndGggLyAxMDI0KX1LaUIuIGAgK1xuICAgICAgYFRlbXBsYXRlcyBsYXJnZXIgdGhhbiAke0xBUkdFX1RFTVBMQVRFX1NJWkVfS0J9S2lCIG11c3QgYmUgdXBsb2FkZWQgdG8gUzMuXFxuYCArXG4gICAgICAnUnVuIHRoZSBmb2xsb3dpbmcgY29tbWFuZCBpbiBvcmRlciB0byBzZXR1cCBhbiBTMyBidWNrZXQgaW4gdGhpcyBlbnZpcm9ubWVudCwgYW5kIHRoZW4gcmUtZGVwbG95OlxcblxcbicsXG4gICAgICBjb2xvcnMuYmx1ZShgXFx0JCBjZGsgYm9vdHN0cmFwICR7cmVzb2x2ZWRFbnZpcm9ubWVudC5uYW1lfVxcbmApKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgdG9vIGxhcmdlIHRvIGRlcGxveSAoXCJjZGsgYm9vdHN0cmFwXCIgaXMgcmVxdWlyZWQpJyk7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZUhhc2ggPSBjb250ZW50SGFzaCh0ZW1wbGF0ZUpzb24pO1xuICBjb25zdCBrZXkgPSBgY2RrLyR7c3RhY2suaWR9LyR7dGVtcGxhdGVIYXNofS55bWxgO1xuXG4gIGFzc2V0TWFuaWZlc3QuYWRkRmlsZUFzc2V0KHRlbXBsYXRlSGFzaCwge1xuICAgIHBhdGg6IHN0YWNrLnRlbXBsYXRlRmlsZSxcbiAgfSwge1xuICAgIGJ1Y2tldE5hbWU6IHRvb2xraXRJbmZvLmJ1Y2tldE5hbWUsXG4gICAgb2JqZWN0S2V5OiBrZXksXG4gIH0pO1xuXG4gIGNvbnN0IHRlbXBsYXRlVVJMID0gYCR7dG9vbGtpdEluZm8uYnVja2V0VXJsfS8ke2tleX1gO1xuICBkZWJ1ZygnU3RvcmluZyB0ZW1wbGF0ZSBpbiBTMyBhdDonLCB0ZW1wbGF0ZVVSTCk7XG4gIHJldHVybiB7IFRlbXBsYXRlVVJMOiB0ZW1wbGF0ZVVSTCB9O1xufVxuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXN0cm95U3RhY2tPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBzdGFjayB0byBiZSBkZXN0cm95ZWRcbiAgICovXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgc2RrOiBJU0RLO1xuICByb2xlQXJuPzogc3RyaW5nO1xuICBkZXBsb3lOYW1lPzogc3RyaW5nO1xuICBxdWlldD86IGJvb2xlYW47XG59XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVzdHJveVN0YWNrKG9wdGlvbnM6IERlc3Ryb3lTdGFja09wdGlvbnMpIHtcbiAgY29uc3QgZGVwbG95TmFtZSA9IG9wdGlvbnMuZGVwbG95TmFtZSB8fCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZTtcbiAgY29uc3QgY2ZuID0gb3B0aW9ucy5zZGsuY2xvdWRGb3JtYXRpb24oKTtcblxuICBjb25zdCBjdXJyZW50U3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIGRlcGxveU5hbWUpO1xuICBpZiAoIWN1cnJlbnRTdGFjay5leGlzdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbW9uaXRvciA9IG9wdGlvbnMucXVpZXQgPyB1bmRlZmluZWQgOiBuZXcgU3RhY2tBY3Rpdml0eU1vbml0b3IoY2ZuLCBkZXBsb3lOYW1lLCBvcHRpb25zLnN0YWNrKS5zdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgY2ZuLmRlbGV0ZVN0YWNrKHsgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLCBSb2xlQVJOOiBvcHRpb25zLnJvbGVBcm4gfSkucHJvbWlzZSgpO1xuICAgIGNvbnN0IGRlc3Ryb3llZFN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrRGVsZXRlKGNmbiwgZGVwbG95TmFtZSk7XG4gICAgaWYgKGRlc3Ryb3llZFN0YWNrICYmIGRlc3Ryb3llZFN0YWNrLnN0YWNrU3RhdHVzLm5hbWUgIT09ICdERUxFVEVfQ09NUExFVEUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXN0cm95ICR7ZGVwbG95TmFtZX06ICR7ZGVzdHJveWVkU3RhY2suc3RhY2tTdGF0dXN9YCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChtb25pdG9yKSB7IGF3YWl0IG1vbml0b3Iuc3RvcCgpOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB3ZSBjYW4gc2tpcCBkZXBsb3ltZW50XG4gKlxuICogV2UgZG8gdGhpcyBpbiBhIGNvbXBsaWNhdGVkIHdheSBieSBwcmVwcm9jZXNzaW5nIChpbnN0ZWFkIG9mIGp1c3RcbiAqIGxvb2tpbmcgYXQgdGhlIGNoYW5nZXNldCksIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG5lc3RlZCBzdGFja3MgaW52b2x2ZWRcbiAqIHRoZSBjaGFuZ2VzZXQgd2lsbCBhbHdheXMgc2hvdyB0aGUgbmVzdGVkIHN0YWNrcyBhcyBuZWVkaW5nIHRvIGJlXG4gKiB1cGRhdGVkLCBhbmQgdGhlIGRlcGxveW1lbnQgd2lsbCB0YWtlIGEgbG9uZyB0aW1lIHRvIGluIGVmZmVjdCBub3RcbiAqIGRvIGFueXRoaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBjYW5Ta2lwRGVwbG95KFxuICBkZXBsb3lTdGFja09wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucyxcbiAgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgcGFyYW1zOiBTdGFja1BhcmFtZXRlcnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcblxuICBjb25zdCBkZXBsb3lOYW1lID0gZGVwbG95U3RhY2tPcHRpb25zLmRlcGxveU5hbWUgfHwgZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnN0YWNrTmFtZTtcbiAgZGVidWcoYCR7ZGVwbG95TmFtZX06IGNoZWNraW5nIGlmIHdlIGNhbiBza2lwIGRlcGxveWApO1xuXG4gIC8vIEZvcmNlZCBkZXBsb3lcbiAgaWYgKGRlcGxveVN0YWNrT3B0aW9ucy5mb3JjZSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBmb3JjZWQgZGVwbG95bWVudGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE5vIGV4aXN0aW5nIHN0YWNrXG4gIGlmICghY2xvdWRGb3JtYXRpb25TdGFjay5leGlzdHMpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogbm8gZXhpc3Rpbmcgc3RhY2tgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wbGF0ZSBoYXMgY2hhbmdlZCAoYXNzZXRzIHRha2VuIGludG8gYWNjb3VudCBoZXJlKVxuICBpZiAoSlNPTi5zdHJpbmdpZnkoZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnRlbXBsYXRlKSAhPT0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgY2xvdWRGb3JtYXRpb25TdGFjay50ZW1wbGF0ZSgpKSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiB0ZW1wbGF0ZSBoYXMgY2hhbmdlZGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRhZ3MgaGF2ZSBjaGFuZ2VkXG4gIGlmICghY29tcGFyZVRhZ3MoY2xvdWRGb3JtYXRpb25TdGFjay50YWdzLCBkZXBsb3lTdGFja09wdGlvbnMudGFncyA/PyBbXSkpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogdGFncyBoYXZlIGNoYW5nZWRgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXJtaW5hdGlvbiBwcm90ZWN0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgaWYgKCEhZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiAhPT0gISFjbG91ZEZvcm1hdGlvblN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbikge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiB0ZXJtaW5hdGlvbiBwcm90ZWN0aW9uIGhhcyBiZWVuIHVwZGF0ZWRgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBQYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZFxuICBpZiAocGFyYW1zLmNoYW5nZWQpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogcGFyYW1ldGVycyBoYXZlIGNoYW5nZWRgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBjYW4gc2tpcCBkZXBsb3lcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGxpc3Qgb2YgdGFncywgcmV0dXJucyB0cnVlIGlmIGlkZW50aWNhbC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZVRhZ3MoYTogVGFnW10sIGI6IFRhZ1tdKTogYm9vbGVhbiB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFUYWcgb2YgYSkge1xuICAgIGNvbnN0IGJUYWcgPSBiLmZpbmQodGFnID0+IHRhZy5LZXkgPT09IGFUYWcuS2V5KTtcblxuICAgIGlmICghYlRhZyB8fCBiVGFnLlZhbHVlICE9PSBhVGFnLlZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRm9ybWF0IGFuIFMzIFVSTCBpbiB0aGUgbWFuaWZlc3QgZm9yIHVzZSB3aXRoIENsb3VkRm9ybWF0aW9uXG4gKlxuICogUmVwbGFjZXMgZW52aXJvbm1lbnQgcGxhY2Vob2xkZXJzICh3aGljaCB0aGlzIGZpZWxkIG1heSBjb250YWluKSxcbiAqIGFuZCByZWZvcm1hdHMgczM6Ly8uLi4vLi4uIHVybHMgaW50byBTMyBSRVNUIFVSTHMgKHdoaWNoIENsb3VkRm9ybWF0aW9uXG4gKiBleHBlY3RzKVxuICovXG5mdW5jdGlvbiByZXN0VXJsRnJvbU1hbmlmZXN0KHVybDogc3RyaW5nLCBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQpOiBzdHJpbmcge1xuICBjb25zdCBkb05vdFVzZU1hcmtlciA9ICcqKkRPTk9UVVNFKionO1xuICAvLyBUaGlzIFVSTCBtYXkgY29udGFpbiBwbGFjZWhvbGRlcnMsIHNvIHN0aWxsIHN1YnN0aXR1dGUgdGhvc2UuXG4gIHVybCA9IGN4YXBpLkVudmlyb25tZW50UGxhY2Vob2xkZXJzLnJlcGxhY2UodXJsLCB7XG4gICAgYWNjb3VudElkOiBlbnZpcm9ubWVudC5hY2NvdW50LFxuICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogZG9Ob3RVc2VNYXJrZXIsXG4gIH0pO1xuXG4gIC8vIFllcywgdGhpcyBpcyBleHRyZW1lbHkgY3J1ZGUsIGJ1dCB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoaXMgc28gSSdtIG5vdCBpbmNsaW5lZCB0byBzcGVuZFxuICAvLyBhIGxvdCBvZiBlZmZvcnQgdHJ5aW5nIHRvIHRocmVhZCB0aGUgcmlnaHQgdmFsdWUgdG8gdGhpcyBsb2NhdGlvbi5cbiAgaWYgKHVybC5pbmRleE9mKGRvTm90VXNlTWFya2VyKSA+IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIFxcJyR7QVdTOjpQYXJ0aXRpb259XFwnIGluIHRoZSBcXCdzdGFja1RlbXBsYXRlQXNzZXRPYmplY3RVcmxcXCcgZmllbGQnKTtcbiAgfVxuXG4gIGNvbnN0IHMzVXJsID0gdXJsLm1hdGNoKC9zMzpcXC9cXC8oW14vXSspXFwvKC4qKSQvKTtcbiAgaWYgKCFzM1VybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgLy8gV2UgbmVlZCB0byBwYXNzIGFuICdodHRwczovL3MzLlJFR0lPTi5hbWF6b25hd3MuY29tWy5jbl0vYnVja2V0L29iamVjdCcgVVJMIHRvIENsb3VkRm9ybWF0aW9uLCBidXQgd2VcbiAgLy8gZ290IGFuICdzMzovL2J1Y2tldC9vYmplY3QnIFVSTCBpbnN0ZWFkLiBDb25zdHJ1Y3QgdGhlIHJlc3QgQVBJIFVSTCBoZXJlLlxuICBjb25zdCBidWNrZXROYW1lID0gczNVcmxbMV07XG4gIGNvbnN0IG9iamVjdEtleSA9IHMzVXJsWzJdO1xuXG4gIGNvbnN0IHVybFN1ZmZpeDogc3RyaW5nID0gcmVnaW9uVXRpbC5nZXRFbmRwb2ludFN1ZmZpeChlbnZpcm9ubWVudC5yZWdpb24pO1xuICByZXR1cm4gYGh0dHBzOi8vczMuJHtlbnZpcm9ubWVudC5yZWdpb259LiR7dXJsU3VmZml4fS8ke2J1Y2tldE5hbWV9LyR7b2JqZWN0S2V5fWA7XG59Il19